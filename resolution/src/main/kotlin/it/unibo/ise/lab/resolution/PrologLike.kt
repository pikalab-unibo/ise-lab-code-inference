/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package it.unibo.ise.lab.resolution

import it.unibo.tuprolog.core.*
import it.unibo.tuprolog.unify.Unificator.Companion.mguWith
import it.unibo.tuprolog.theory.Theory

sealed class Solution(open val query: Directive) {
    data class Yes(override val query: Directive, val unifier: Substitution.Unifier) : Solution(query) {
        val solution: Directive by lazy {
            query.apply(unifier).castToDirective()
        }
    }
    data class No(override val query: Directive) : Solution(query)
    data class Halt(override val query: Directive, val error: String) : Solution(query)
}

fun solve(theory: Theory, goals: Directive): Sequence<Solution> = sequence {
    for (solution in solve(theory, goals, goals.bodyItems.toList(), Substitution.empty())) {
        yield(solution)
        if (solution is Solution.Halt) return@sequence
        yield(Solution.No(goals))
    }
}

fun solve(theory: Theory, query: Directive, goals: List<Term>, unifier: Substitution): Sequence<Solution> =
    if (goals.isEmpty() || unifier !is Substitution.Unifier) emptySequence()
    else sequence {
        when (val goal = goals.first().apply(unifier)) {
            !is Struct -> {
                yield(Solution.Halt(query, "Invalid goal $goal"))
            }
            is Truth -> {
                if (goal.isTrue) {
                    yield(Solution.Yes(query, unifier))
                }
            }
            else -> {
                for (rule in theory[goal]) {
                    yieldAll(
                        solve(theory, query, goals.drop(1), unifier + (goal mguWith rule.head))
                    )
                }
            }
        }
    }
